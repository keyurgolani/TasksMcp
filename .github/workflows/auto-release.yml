name: Auto Release

on:
  push:
    branches: [ main ]
    paths:
      - 'src/**'
      - 'package.json'
      - 'package-lock.json'
  workflow_dispatch:
    inputs:
      release-type:
        description: 'Release type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      skip-ci:
        description: 'Skip CI checks'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      should-release: ${{ steps.check.outputs.should-release }}
      release-type: ${{ steps.check.outputs.release-type }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Analyze changes and determine release need
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "release-type=${{ github.event.inputs.release-type }}" >> $GITHUB_OUTPUT
            echo "Manual release triggered: ${{ github.event.inputs.release-type }}"
            exit 0
          fi
          
          echo "üîç Analyzing changes to determine release necessity..."
          
          # Get changed files
          CHANGED_FILES=$(git diff HEAD~1 HEAD --name-only)
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Check for version changes in package.json
          if echo "$CHANGED_FILES" | grep -q "package.json"; then
            echo "üì¶ package.json changed, checking version..."
            CURRENT_VERSION=$(node -p "require('./package.json').version")
            git checkout HEAD~1 -- package.json
            PREVIOUS_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "0.0.0")
            git checkout HEAD -- package.json
            
            if [[ "$CURRENT_VERSION" != "$PREVIOUS_VERSION" ]]; then
              echo "‚úÖ Version manually changed from $PREVIOUS_VERSION to $CURRENT_VERSION"
              echo "should-release=true" >> $GITHUB_OUTPUT
              echo "release-type=manual" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # Analyze types of changes
          CORE_CHANGES=$(echo "$CHANGED_FILES" | grep -c "^src/core/" || echo "0")
          HANDLER_CHANGES=$(echo "$CHANGED_FILES" | grep -c "^src/handlers/" || echo "0")
          TYPE_CHANGES=$(echo "$CHANGED_FILES" | grep -c "^src/types/" || echo "0")
          CONFIG_CHANGES=$(echo "$CHANGED_FILES" | grep -c "^src/config/" || echo "0")
          
          # Check for breaking changes in commit messages
          BREAKING_COMMITS=$(git log HEAD~1..HEAD --pretty=format:"%s" | grep -c "!" || echo "0")
          
          # Check commit types for semantic versioning
          FEAT_COMMITS=$(git log HEAD~1..HEAD --pretty=format:"%s" | grep -c "^feat" || echo "0")
          FIX_COMMITS=$(git log HEAD~1..HEAD --pretty=format:"%s" | grep -c "^fix" || echo "0")
          
          echo "üìä Change Analysis:"
          echo "- Core changes: $CORE_CHANGES"
          echo "- Handler changes: $HANDLER_CHANGES"
          echo "- Type changes: $TYPE_CHANGES"
          echo "- Config changes: $CONFIG_CHANGES"
          echo "- Breaking commits: $BREAKING_COMMITS"
          echo "- Feature commits: $FEAT_COMMITS"
          echo "- Fix commits: $FIX_COMMITS"
          
          # Determine release type based on changes
          if [[ $BREAKING_COMMITS -gt 0 ]]; then
            echo "üö® Breaking changes detected - major release needed"
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "release-type=major" >> $GITHUB_OUTPUT
          elif [[ $FEAT_COMMITS -gt 0 ]] || [[ $HANDLER_CHANGES -gt 0 ]] || [[ $CORE_CHANGES -gt 1 ]]; then
            echo "üöÄ New features or significant core changes - minor release needed"
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "release-type=minor" >> $GITHUB_OUTPUT
          elif [[ $FIX_COMMITS -gt 0 ]] || [[ $CORE_CHANGES -gt 0 ]] || [[ $TYPE_CHANGES -gt 0 ]] || [[ $CONFIG_CHANGES -gt 0 ]]; then
            echo "üêõ Bug fixes or minor changes - patch release needed"
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "release-type=patch" >> $GITHUB_OUTPUT
          else
            # Check if any source files changed at all
            SRC_CHANGES=$(echo "$CHANGED_FILES" | grep -c "^src/" || echo "0")
            if [[ $SRC_CHANGES -gt 0 ]]; then
              echo "üìù Source code changes detected - patch release needed"
              echo "should-release=true" >> $GITHUB_OUTPUT
              echo "release-type=patch" >> $GITHUB_OUTPUT
            else
              echo "‚ÑπÔ∏è No significant changes detected - skipping release"
              echo "should-release=false" >> $GITHUB_OUTPUT
            fi
          fi

  run-ci:
    needs: check-changes
    if: needs.check-changes.outputs.should-release == 'true' && github.event.inputs.skip-ci != 'true'
    uses: ./.github/workflows/ci.yml
    secrets: inherit

  auto-version-and-release:
    needs: [check-changes, run-ci]
    if: |
      always() && 
      needs.check-changes.outputs.should-release == 'true' && 
      (needs.run-ci.result == 'success' || github.event.inputs.skip-ci == 'true')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Install dependencies
        run: npm ci

      - name: Determine version bump
        id: version
        run: |
          RELEASE_TYPE="${{ needs.check-changes.outputs.release-type }}"
          
          if [[ "$RELEASE_TYPE" == "manual" ]]; then
            # Version already changed manually, just get current version
            CURRENT_VERSION=$(node -p "require('./package.json').version")
            echo "version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
            echo "tag=v${CURRENT_VERSION}" >> $GITHUB_OUTPUT
            echo "Manual version: ${CURRENT_VERSION}"
          else
            # Auto-bump version
            echo "Auto-bumping version: ${RELEASE_TYPE}"
            NEW_VERSION=$(npm version ${RELEASE_TYPE} --no-git-tag-version)
            echo "version=${NEW_VERSION#v}" >> $GITHUB_OUTPUT
            echo "tag=${NEW_VERSION}" >> $GITHUB_OUTPUT
            echo "New version: ${NEW_VERSION}"
          fi

      - name: Update package-lock.json
        run: |
          npm install --package-lock-only
          git add package.json package-lock.json

      - name: Generate dynamic changelog entry
        id: changelog
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          echo "Generating changelog for version ${VERSION}"
          echo "Previous tag: ${LAST_TAG}"
          
          # Create changelog file
          cat > changelog.md << EOF
          ## [${VERSION}] - $(date +%Y-%m-%d)
          
          ### üîÑ Auto-Release Summary
          This version was automatically generated based on detected changes.
          EOF
          
          if [[ -n "$LAST_TAG" ]]; then
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s (%h)" --no-merges)
            
            if [[ -n "$COMMITS" ]]; then
              FEAT_COUNT=$(echo "$COMMITS" | grep -c "^feat" || echo "0")
              FIX_COUNT=$(echo "$COMMITS" | grep -c "^fix" || echo "0")
              DOCS_COUNT=$(echo "$COMMITS" | grep -c "^docs" || echo "0")
              CHORE_COUNT=$(echo "$COMMITS" | grep -c "^chore" || echo "0")
              OTHER_COUNT=$(echo "$COMMITS" | grep -cv "^(feat|fix|docs|chore)" || echo "0")
              TOTAL_COUNT=$(echo "$COMMITS" | wc -l)
              
              echo "
          ### üìä Change Summary
          - **Total commits:** ${TOTAL_COUNT}
          - **New features:** ${FEAT_COUNT}
          - **Bug fixes:** ${FIX_COUNT}
          - **Documentation:** ${DOCS_COUNT}
          - **Maintenance:** ${CHORE_COUNT}
          - **Other changes:** ${OTHER_COUNT}
          
          ### üìù Detailed Changes" >> changelog.md
              
              # Add commit details
              echo "$COMMITS" | head -10 | while read commit; do
                echo "          - $commit" >> changelog.md
              done
              
              FILES_CHANGED=$(git diff --name-only ${LAST_TAG}..HEAD | wc -l)
              echo "
          ### üìà Code Changes
          - **Files modified:** ${FILES_CHANGED}" >> changelog.md
              
            else
              echo "
          ### Changes
          No commits found since ${LAST_TAG}" >> changelog.md
            fi
          else
            TOTAL_COMMITS=$(git rev-list --count HEAD)
            echo "
          ### üéâ Initial Release
          - **Total development commits:** ${TOTAL_COMMITS}
          - **MCP tools implemented:** 7
          - **Production ready:** ‚úÖ" >> changelog.md
          fi
          
          echo "
          ### üì¶ Installation
          \`\`\`bash
          npx task-list-mcp@${VERSION}
          \`\`\`" >> changelog.md
          
          CHANGELOG_ENTRY=$(cat changelog.md)
          
          echo "changelog-entry<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG_ENTRY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Commit version bump
        if: needs.check-changes.outputs.release-type != 'manual'
        run: |
          # Get dynamic commit summary
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [[ -n "$LAST_TAG" ]]; then
            COMMITS_COUNT=$(git rev-list ${LAST_TAG}..HEAD --count)
            FILES_CHANGED=$(git diff --name-only ${LAST_TAG}..HEAD | wc -l)
            
            # Get primary change types
            CHANGE_TYPES=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s" --no-merges | \
              grep -o "^[a-z]*" | sort | uniq -c | sort -nr | head -3 | \
              awk '{print $2}' | tr '\n' ', ' | sed 's/,$//')
          else
            COMMITS_COUNT=$(git rev-list --count HEAD)
            FILES_CHANGED=$(find src -type f -name "*.ts" | wc -l)
            CHANGE_TYPES="initial release"
          fi
          
          git commit -m "chore: bump version to ${{ steps.version.outputs.version }}

          Auto-generated version bump for release.
          
          üìä Release Summary:
          - Commits: ${COMMITS_COUNT}
          - Files changed: ${FILES_CHANGED}
          - Primary changes: ${CHANGE_TYPES}
          - Release type: ${{ needs.check-changes.outputs.release-type }}
          
          This version bump was automatically generated based on detected
          source code changes and follows semantic versioning principles."

      - name: Create and push tag
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          echo "Creating tag: $TAG"
          
          # Check if tag already exists
          if git tag -l | grep -q "^${TAG}$"; then
            echo "‚ö†Ô∏è Tag $TAG already exists, skipping tag creation"
            echo "Existing tags:"
            git tag -l | grep -E "^v[0-9]+\.[0-9]+\.[0-9]+$" | sort -V | tail -5
          else
            git tag $TAG
            echo "‚úÖ Created tag: $TAG"
          fi
          
          # Push changes and tags
          git push origin main --tags
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Trigger release workflow
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              console.log('Triggering publish workflow...');
              console.log('Version:', '${{ steps.version.outputs.version }}');
              console.log('Tag:', '${{ steps.version.outputs.tag }}');
              
              const response = await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'publish.yml',
                ref: 'main',
                inputs: {
                  version: '${{ steps.version.outputs.version }}'
                }
              });
              
              console.log('Workflow dispatch successful:', response.status);
            } catch (error) {
              console.error('Failed to trigger workflow:', error.message);
              console.error('Error details:', error);
              
              // Check if it's a permissions issue
              if (error.status === 403) {
                console.error('This appears to be a permissions issue.');
                console.error('Make sure the workflow has actions: write permission');
                console.error('and that GITHUB_TOKEN has workflow permissions.');
              }
              
              // Don't fail the workflow if publish trigger fails
              console.log('Continuing without triggering publish workflow...');
            }

  notify-auto-release:
    needs: [check-changes, auto-version-and-release]
    runs-on: ubuntu-latest
    if: always() && needs.check-changes.outputs.should-release == 'true'
    steps:
      - name: Auto-release notification
        run: |
          if [[ "${{ needs.auto-version-and-release.result }}" == "success" ]]; then
            echo "üöÄ Auto-release initiated successfully!"
            echo "üì¶ Version: ${{ needs.auto-version-and-release.outputs.version }}"
            echo "üè∑Ô∏è Tag: ${{ needs.auto-version-and-release.outputs.tag }}"
            echo "‚è≥ Release workflow will start shortly..."
          else
            echo "‚ùå Auto-release failed. Check the logs for details."
            exit 1
          fi